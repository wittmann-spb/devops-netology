

# Домашнее задание к занятию "5.3. Введение. Экосистема. Архитектура. Жизненный цикл Docker контейнера"

## Задача 1

<details>
<summary>.</summary>

> Сценарий выполения задачи:
> 
> - создайте свой репозиторий на https://hub.docker.com;
> - выберете любой образ, который содержит веб-сервер Nginx;
> - создайте свой fork образа;
> - реализуйте функциональность:
> запуск веб-сервера в фоне с индекс-страницей, содержащей HTML-код ниже:
> ```
> <html>
> <head>
> Hey, Netology
> </head>
> <body>
> <h1>I’m DevOps Engineer!</h1>
> </body>
> </html>
> ```
> Опубликуйте созданный форк в своем репозитории и предоставьте ответ в виде ссылки на https://hub.docker.com/username_repo.

</details>

[Ссылка на Docker образ] (https://hub.docker.com/r/vitmandotru/devops-netology)

## Задача 2

<details>
<summary>Задание</summary>

> Посмотрите на сценарий ниже и ответьте на вопрос:
> "Подходит ли в этом сценарии использование Docker контейнеров или лучше подойдет виртуальная машина, физическая машина? Может быть возможны разные варианты?"
> 
> Детально опишите и обоснуйте свой выбор.
> 
> --
> 
> Сценарий:
> 
> - Высоконагруженное монолитное java веб-приложение;
> - Nodejs веб-приложение;
> - Мобильное приложение c версиями для Android и iOS;
> - Шина данных на базе Apache Kafka;
> - Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;
> - Мониторинг-стек на базе Prometheus и Grafana;
> - MongoDB, как основное хранилище данных для java-приложения;
> - Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.

</details>

> Высоконагруженное монолитное java веб-приложение;

Зависит от того, может ли приложение масштабироваться и взаимодействовать с каким-нибудь балансировщиком. Если архитектура это позволяет - то контейнеры будут удобней виртуальных машин, т.к. они быстрей разворачиваются, менее требовательны к месту и прочим ресурсам.

Если в приложение не заложено масштабирование, тогда лучше физическая машина, чтобы не тратить лишние ресурсы на виртуализацию.

> Nodejs веб-приложение;

Докер подойдёт хорошо, т.к. это позволит быстро развернуть приложение со всеми необходимыми библиотеками. 

> Мобильное приложение c версиями для Android и iOS;

Скорей всего нет, т.к. я не нашел информации о какой-то интеграции инструментов разработки под мобильные платформы с Docker. 

Это могло бы пригодиться, например для автотестов и удобства разработки, чтобы поделиться билдом приложения с коллегами и запустить его без боли и так далее. 

[Есть](https://github.com/budtmo/docker-android) проекты, посвящённые запуску эмуляторов и приложений для Android/iOS с использованием Docker.

Даже если это будет работать, как такие приложения поведут себя в реальной среде на ARM устройствах в интеграции с маркетами мобильных платформ - вопрос.

> Шина данных на базе Apache Kafka;

Да, вполне. Брокеры активно используются в современных распределённых приложениях, доставка приложения через докер на сервера и разработчикам в тестовую среду должна упростить жизнь. 

Ещё очень важно иметь возможность быстро откатиться если приложение обновили, и в продакшене что-то пошло не так. Докер будет особенно удобен чтобы "вернуть как было" один из центральных узлов приложения - шину.

> Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;

Docker подойдёт лучше, так как он будет удобней для кластеризации: у контейнеров меньше оверхед.

> Мониторинг-стек на базе Prometheus и Grafana;

Докер [подойдёт](https://grafana.com/blog/2019/05/07/ask-us-anything-should-i-run-prometheus-in-a-container/) для этой задачи хорошо. Разворвачивать node_exporter с Docker скорей всего не стоит, т.к. ему требуется прямой доступ к метрикам ядра, но Prometheus и Grafana можно использовать в Докере. 

> MongoDB, как основное хранилище данных для java-приложения;

Да, вполне подойдёт Docker. У MongoDB даже есть официальный образ на [Docker Hub](https://hub.docker.com/_/mongo). 

> Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.

В общем случае, думаю удобней будет виртуальная машина, т.к. серверу GitLab не требуется масштабирование или деплой новой версии несколько раз в день, а виртуальная машина позволит очень удобно делать бекапы и при необходимости мигрировать её в кластере. 

Если в компании повсеместно используются контейнеры - тогда, может, будет удобней Docker, т.к. инженерам это будет привычней.


## Задача 3

<details>
<summary>.</summary>

> - Запустите первый контейнер из образа ***centos*** c любым тэгом в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
> - Запустите второй контейнер из образа ***debian*** в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
> - Подключитесь к первому контейнеру с помощью ```docker exec``` и создайте текстовый файл любого содержания в ```/data```;
> - Добавьте еще один файл в папку ```/data``` на хостовой машине;
> - Подключитесь во второй контейнер и отобразите листинг и содержание файлов в ```/data``` контейнера.

</details>

1. Запуск контейнеров

    ```bash
    vagrant@server1:~/netologydevops53/3$ docker run -it --rm -d --name centos -v $(pwd)/data:/data centos:latest
    934ca2651653e4669c5ce83ee1f37c78277d2bd80ba465f9148fb164a160f4d0
    vagrant@server1:~/netologydevops53/3$ docker run -it --rm -d --name debian -v $(pwd)/data:/data debian:stable
    c7444ead8f5c2508e8774b05e2867973fc8aac44800352f77c9f6c506aa904e9
    ```

2. Файл из контейнера с CentOS

    ```bash
    vagrant@server1:~/netologydevops53/3$ docker exec -it centos bash
    [root@934ca2651653 /]# echo "Hello Netology from CentOS!" > /data/centos.txt
    [root@934ca2651653 /]# exit
    ```

3. Файл с хоста

    ```bash
    vagrant@server1:~/netologydevops53/3$ echo "Hellow Netology from Host!" > data/host.txt
    ```
   
4. Файлы в директории `/data` в контейнере с Debian

    ```bash
    vagrant@server1:~/netologydevops53/3$ docker exec -it debian bash
    root@c7444ead8f5c:/# ls -l /data/
    total 8
    -rw-r--r-- 1 root root 28 Nov  6 12:01 centos.txt
    -rw-rw-r-- 1 1000 1000 27 Nov  6 12:02 host.txt
    ```

